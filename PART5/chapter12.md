# 물리적 저장 장치 시스템
> 컴퓨터의 저장장치를 빠르게 복습해보자.

# 물리적 저장 장치 매체

대부분의 컴퓨터에서 사용중인 저장장치를 빠르고, 비싼 순서대로 정리해보자.

캐시 → 주기억장치 → 플래시 메모리 → HDD → 광디스크 → 테이프 순서대로 감.

| **계층** | **이름** | **특징** |
| --- | --- | --- |
| 상위 | 🔴 Primary Storage | 캐시, 주기억장치 → 매우 빠르나 고가, 휘발성 |
| 중위 | 🟠 Secondary (Online) Storage | 플래시 메모리, HDD → 중간 속도, 비휘발성 |
| 하위 | 🟢 Tertiary (Offline) Storage | 테이프, 광디스크 → 느리지만 매우 저렴함, 비휘발성 |

⚡ **Main memory 이상**은 휘발성, **Flash memory 이하**는 비휘발성임.

# 저장장치 인터페이스

## **직접 연결하기**

- 자기디스크(HDD) 및 플래시 기반 SSD는 **고속 인터페이스**를 통해 컴퓨터와 직접 연결됨.
- 주요 디스크 인터페이스는 다음과 같음:

| **인터페이스** | **특징** |
| --- | --- |
| **SATA (Serial ATA)** | 💡 일반 사용자용, SATA-3는 최대 6Gbps (600MB/s) 지원 |
| **SAS (Serial Attached SCSI)** | 🔧 서버 전용, SAS v3는 최대 12Gbps 지원 |
| **NVMe + PCIe** | ⚡ SSD 최적화 논리 인터페이스, PCIe를 통해 내부 고속 전송 가능 |

## 네트워크로 연결하기

1. SAN **(Storage Area Network)**
- 다수의 디스크를 고속 네트워크로 연결해 서버들이 공유함
- RAID 기술로 구성되어 **큰 단일 디스크처럼 인식**되며, 높은 신뢰성 제공.
- 사용되는 기술
    - **iSCSI**: IP 네트워크 위에서 SCSI 명령 전송
    - **Fiber Channel (FC)**: 1.6~12GB/s 속도 지원
    - **InfiniBand**: 매우 낮은 지연과 높은 대역폭 제공

2. NAS (Network Attached Storage)

- 📁 파일 단위 접근을 제공하는 저장 방식
- 서버에서 직접 디스크처럼 접근하지 않고 **파일 시스템 인터페이스 제공**
- 사용되는 프로토콜:
    - **NFS**
    - **CIFS** (현재는 SMB로 대체됨)

1. 클라우드
- 데이터가 **클라우드에 저장**되고 **API를 통해 접근**함.
- 데이터베이스와 함께 위치하지 않으면 **지연(latency)이 수십~수백 밀리초로 큼**
- DBMS의 기본 저장소로는 부적절하지만, 이미지, 로그 등 **객체 저장용으로는 적합함.**

# 자가 디스크

- 자기 디스크는 여전히 현대 컴퓨터 시스템의 **주요 보조 저장 매체**임.
- **대용량 데이터 저장에는 SSD보다 여전히 자기 디스크가 경제적인 측면에서 유리.**

**디스크 블록 & 페이지**

- DBMS는 데이터를 하드디스크에서 **블록 단위(block)**로 읽고 씀.
    - 일반적으로 4KB ~ 16KB 크기
    - 디스크의 논리적 저장 단위임
- 페이지(page)라는 용어도 종종 블록을 지칭할 때 사용됨.

![](images/chapter12_1.png) ![](images/chapter12_2.png)

**접근 패턴이 성능에 미치는 영향**

| **접근 유형** | **설명** | **DBMS 영향** |
| --- | --- | --- |
| 🔄 순차 접근 | 연속된 블록 읽기 | 빠른 데이터 전송 가능, **배치 처리에 유리** |
| 🎯 랜덤 접근 | 임의 위치의 블록 접근 | I/O 작업 증가, **인덱스 탐색 등에서 발생** |
- 랜덤 접근은 각 요청마다 탐색 시간(Seek Time)과 회전 지연(Rotational Latency)이 발생하므로, 성능 저하의 주 원인이 됨.
- **DBMS 성능 튜닝 시 디스크 접근 패턴 분석이 중요함.**

**디스크 성능 지표와 DB I/O**

| **지표** | **설명** | **DB와의 연관성** |
| --- | --- | --- |
| ⚡ 접근 시간 | 데이터 요청 → 전송 시작까지의 시간 (평균 5~20ms) | 쿼리 처리 속도에 큰 영향 |
| 🧲 데이터 전송률 | 디스크 → 메모리 전송 속도 (최대 50~200MB/s) | 대용량 데이터 로딩에 중요 |
| 🔁 IOPS | 초당 처리 가능한 랜덤 I/O 횟수 (보통 50~200) | **OLTP 시스템 성능에 중요** |
| 🔒 신뢰성(MTTF) | 평균 고장 시간 (500K~1.2M 시간) | **데이터 보존 및 백업 전략과 관련됨** |

**디스크 컨트롤러의 역할 (DB 관점)**

- **DBMS는 OS를 통해 디스크 컨트롤러에 접근함**.
- 디스크 컨트롤러는 다음과 같은 기능 수행:
    - ✅ 읽기/쓰기 명령 수행
    - ✅ 체크섬 기반 **데이터 손상 검출**
    - ✅ 손상된 섹터는 **다른 위치로 자동 재매핑**

➡️ **안정적인 DB 운영**을 위해 중요한 하드웨어 기반 기능임.

# 플래시 메모리

- **SSD는 NAND 플래시 기반**으로 구성되며, 디스크처럼 **블록 단위 I/O**를 지원함.
- **플래시 페이지 = 디스크 섹터** 개념과 유사 (보통 4KB).
- DBMS나 파일 시스템은 **자기 디스크와 동일한 방식으로 접근** 가능함.

**<플래시는 I/O 성능이 자기 디스크보다 훨씬 뛰어남>**

| **지표** | **SSD (SATA/NVMe 기준)** | **자기 디스크와의 차이점** |
| --- | --- | --- |
| **랜덤 읽기 지연** | 20~100μs | HDD는 5~10ms → 수백 배 빠름 |
| **순차 전송률** | SATA: 400500MB/s  NVMe: 23GB/s | HDD는 최대 200MB/s |
| **IOPS (4KB 블록 기준)** | QD-1: 10K  QD-32: 100K ~ 350K+ | HDD는 50~200 IOPS 수준 |

**따라서 OLTP 같은 고빈도 랜덤 I/O 처리에 적합함**

**<플래시의 쓰기/삭제 특성과 DB 설계의 연결점>**

- **쓰기 연산은 느리고 복잡함**:
    - 페이지는 직접 덮어쓰기 불가능 → 삭제 후 재기록 필요
    - **Erase Block 단위로 삭제됨** (보통 256KB ~ 1MB)
    - 삭제 속도는 2~5ms로 느림
- **지속적인 쓰기에는 내구성 제한 존재**:
    - 페이지별 **삭제 가능 횟수: 10만~100만회**
    - **수명 제한**으로 인해 “wear leveling” 기법 사용됨

➡️ DBMS는 자주 갱신되는 데이터(hot data)와 잘 안 바뀌는 데이터(cold data)를 구분하여 배치하면 SSD 효율을 높일 수 있음.

**<Flash Translation Layer (FTL)의 역할>**

| **기능** | **설명** |
| --- | --- |
| **논리 → 물리 주소 매핑** | 쓰기 시 새로운 물리 페이지로 매핑 변경 |
| **삭제 페이지 재정리(Garbage Collection)** | 삭제된 페이지를 모아 Erase Block 정리 |
| **Wear Leveling** | 많이 삭제된 블록에는 cold data 배치, 적게 삭제된 곳에 hot data 저장 |
| **결함 페이지 처리** | 오류 난 페이지는 제거하고 다른 블록으로 대체 |

이 모든 처리는 **플래시 메모리 컨트롤러에서 자동 수행**되며, DBMS는 이를 신경 쓸 필요 없음.

<**하이브리드 디스크와 캐싱 활용>**

**하이브리드 디스크(HDD + SSD)**:

- SSD는 캐시 용도, HDD는 데이터 저장 용도
- **자주 읽지만 갱신이 적은 데이터**를 SSD에 저장하면 효율적임

**SAN/NAS 시스템도 SSD 캐시를 활용 가능**: 

- **DB 쿼리 성능 향상에 기여**

# RAID

RAID (Redundant Arrays of Independent Disks)는 여러 디스크를 결합해 신뢰성(reliability)과 성능(performance)을 향상시키는 디스크 구성 방식임.

**<데이터 무결성과 고가용성: RAID의 신뢰성 확보 방법>**

| **개념** | **설명** |
| --- | --- |
| **미러링 (RAID 1)** | 동일 데이터를 두 개의 디스크에 저장함.  하나의 디스크가 고장 나도 다른 디스크에서 복구 가능 |
| **복구 가능 시간 = 수리 시간** | 평균 디스크 수명(MTTF)과 복구 시간(MTTR)에 따라 **전체 데이터 손실까지의 시간**이 결정됨 |
| **전원 장애 대비** | 같은 블록에 동시에 쓰는 중 전원 꺼질 경우 **불일치 상태 발생 가능** → 순차 쓰기 + 재기동 후 복구 절차 필요 |

<**성능 향상: 디스크 병렬 처리**>

디스크 병렬 처리에서 성능을 향상시키는 방법을 알아보자.

| **개념** | **설명** |
| --- | --- |
| **디스크 스트라이핑 (Striping)** | 데이터를 여러 디스크에 나눠 저장함 |
| **블록 수준 스트라이핑 (RAID 0)** | 블록 단위로 데이터를 분산시켜 **읽기/쓰기 속도 향상** |
| **병렬 I/O** | 대용량 파일은 병렬로 여러 블록 읽기 가능, 작은 요청도 병렬화 가능 |
| **목표** | (1) 다수 소형 접근 분산 처리 (2) 대형 접근 병렬 처리로 지연 시간 최소화 |

<**주요 RAID 레벨 비교**>

| **RAID 수준** | **구성 방식** | **신뢰성** | **성능** | **DBMS 적합도** |
| --- | --- | --- | --- | --- |
| **RAID 0** | 블록 스트라이핑만 있음 | ❌ 없음 | ✅ 매우 빠름 | 로그, 캐시 등 비중요 데이터 |
| **RAID 1** | 미러링 | ✅ 매우 높음 | ✅ 랜덤 쓰기 성능 우수 | DB 로그, 트랜잭션 처리 시스템 |
| **RAID 5** | 블록 스트라이핑 + 분산 패리티 | ⭕ 보통 (1개 디스크 고장 허용) | ⚠️ 랜덤 쓰기 성능 저하 | 읽기 위주 DB 시스템 |
| **RAID 6** | RAID 5 + 이중 패리티 (P+Q) | ✅ 매우 높음 (2개 디스크 고장 허용) | ⭕ RAID 5 수준 | 중요 데이터 보호용 DB |

 RAID 6은 **레이턴트 오류(latent failure)**와 같은 **감지되지 않은 오류**에 대비 가능함.

<**하드웨어 vs 소프트웨어 RAID**>

| **항목** | **하드웨어 RAID** | **소프트웨어 RAID** |
| --- | --- | --- |
| **구현 방식** | 전용 컨트롤러 사용 | OS 또는 소프트웨어에서 구현 |
| **복구 성능** | ✅ 비휘발성 메모리로 미완성 쓰기 처리 | ❌ 쓰기 불완료 블록 확인 필요 |
| **핫스왑 지원** | ✅ 디스크 교체 후 자동 복구 가능 | ⚠️ OS 재시작 필요할 수 있음 |
| **스크러빙(Scrubbing)** | ✅ 주기적으로 오류 스캔 및 복구 | 일부만 지원 |

**<DBMS에서 RAID 선택 시 고려사항>**

| **고려 요소** | **설명** |
| --- | --- |
| 💰 **비용** | 디스크 수 증가에 따른 저장 비용 |
| ⚡ **성능 요구** | 랜덤 I/O 속도 vs 순차 쓰기 효율 |
| 🔁 **재구축 시간** | 디스크 복구 시 전체 성능에 영향 |
| 🛡️ **데이터 중요도** | 로그, 트랜잭션, 백업 등 중요도에 따라 RAID 선택 |

➡️ **DBMS 추천 예시**

- 트랜잭션 로그: **RAID 1**
- 읽기 많은 분석 시스템: **RAID 5**
- 미션 크리티컬 데이터: **RAID 6**

**기타 활용**

- **SSD 내부에도 RAID 구조가 적용됨** → 플래시 페이지 오류 방지
- **테이프 어레이**나 **무선 방송** 등에도 RAID 구조 확장 가능

# **디스크 블록 접근**

**📦 1. 블록 단위 I/O 방식**

- **DBMS는 데이터를 디스크에서 블록 단위(block)로 읽고 씀.**
- 요청은 보통 (디스크 ID, 블록 번호) 또는 (파일 ID, 블록 번호) 형식임.
- **OS와 DBMS 모두 디스크에서 블록을 가져와 메모리에 저장하고 사용함.**

**🔄 2. 접근 패턴: 순차 vs 랜덤**

| **접근 유형** | **설명** | **성능 영향** |
| --- | --- | --- |
| 📏 순차 접근 | 연속된 블록 번호 요청 | 빠른 처리, 디스크 탐색 최소화 |
| 🎯 랜덤 접근 | 무작위 위치 블록 요청 | 탐색/회전 지연 증가 → IOPS 감소 |
- **자기 디스크(HDD)는 랜덤 접근이 성능에 큰 영향을 줌.**
- **SSD도 어느 정도 영향 있음.**

**🚀 3. 디스크 접근 최적화 기법**

| **기법** | **설명** | **DB와의 연관성** |
| --- | --- | --- |
| 🧠 **버퍼링(Buffering)** | 읽은 블록을 메모리에 저장하여 이후 재사용 | 버퍼 캐시 활용으로 I/O 횟수 감소 |
| ⏩ **리드어헤드(Read-Ahead)** | 순차적 블록들을 미리 읽어옴 | 순차 접근 쿼리에서 효과적 |
| 🏢 **스케줄링(Scheduling)** | 디스크 암 움직임 최소화 순서로 I/O 요청 처리 | 탐색 시간 줄여 I/O 효율 향상 |
| 🗃️ **파일 조직 최적화** | 파일을 인접 블록/실린더에 배치 | 쿼리 성능 향상, 단편화 최소화 |
| 🔋 **NVRAM 기반 쓰기 버퍼** | 비휘발성 버퍼에 우선 기록 → 나중에 디스크에 저장 | 트랜잭션 처리 시스템 성능 향상 |
| 🧹 **디스크 단편화 정리** | 파일 블록 재배치로 접근 최적화 | 대형 테이블 접근 속도 향상 |

**⚡ 4. NVRAM을 활용한 쓰기 성능 향상**

- DB 업데이트는 반드시 **디스크에 기록**되어야 하므로 **쓰기 지연(latency)**이 중요함.
- NVRAM(비휘발성 메모리)에 먼저 기록하고, 이후 디스크에 최적 경로로 기록.
- 장애 발생 시에도 NVRAM의 내용을 바탕으로 복구 가능함.

📌 주로 **RAID 컨트롤러** 또는 고급 디스크 장비에 내장됨.

**🧠 5. 디스크 접근 최적화는 쿼리 처리와도 연관됨**

- Chapter 15에서 배울 **쿼리 최적화 알고리즘들**도 디스크 접근 수를 줄이는 방향으로 설계됨.
- 특히 **랜덤 접근 횟수를 줄이는 전략**은 성능에 결정적인 영향을 미침.