# B+ 트리 인덱스 파일

우리가 [인덱싱 (1) - 순서 인덱스](chapter14_1.md)에서 다룬 순서 인덱스는 한계를 가지고 있다.

1. 파일이 커질수록 인덱스를 조회하는 성능이 떨어진다. 
2. 파일이 커질수록 데이터를 순차 탐색하는 성능이 떨어진다.

파일을 재구성하면 이 문제를 해결할 수 있으나, 이를 자주 수행하는 것은 바람직하지 않음

그래서 나온 대안 중 하나가 바로, B+ 트리 구조임.

B+ 트리는 다음과 같은 트리의 특징을 가지고 있음:

- 균형 트리 구조(balanced tree) 임.
- root에서 leaf까지의 경로 길이가 모두 동일함 → 균형 트리 조건 만족.
- 루트 노드를 제외한 모든 비단말 노드(non-leaf node) 는 자식 노드를 $⌈n/2⌉$개 이상, $n$개 이하 가짐. 여기서 $n$은 트리의 차수로 고정된 값임.
- 루트 노드는 최소 2개에서 최대 $n$개까지 자식을 가질 수 있음.

## **B+ 트리**

**📚 B+-트리는 다단계 인덱스 구조임**

- B+-트리는 다단계 인덱스(multilevel index) 구조를 가지며, 기존의 인덱스-순차 파일 구조와는 다름.
- **전제**: 일단 모든 검색 키(search key)는 **고유(unique)** 하다고 가정함 (즉, 하나의 레코드에만 존재).
- **중복 키에 대한 처리**는 뒤에서 다룸.

**🔗 노드의 구조**

**📦 일반 노드 구조**

- 하나의 노드는 최대 n−1개의 **정렬된 검색 키 값**$(K_1, K_2, \cdots, K_{n-1})$ 과 n개의 **포인터**$(P_1, P_2, \cdots, P_n)$ 를 가짐.
- 키는 항상 **오름차순으로 정렬**되어 있음 $(K_1 < K_2 < \cdots < K_{n-1})$.

**🍃 리프 노드 구조 (Leaf Nodes)**

- 포인터 $P_i$는 해당 키 $K_i$가 있는 **실제 레코드를 가리킴**.
- 마지막 포인터 $P_n$은 **특수한 용도**로 사용됨 → 아래에서 설명함.
- 하나의 리프 노드는 최대 $n−1$개의 키를 가질 수 있고, 최소 $⌈(n−1)/2⌉$개의 키를 가져야 함.
    - 예: $n = 4$이면 최소 $2$개, 최대 $3$개의 키 보유 가능.
- 리프 노드 간에도 **정렬 관계 유지됨**:
    - $L_i$가 $L_j$보다 왼쪽에 있다면, $L_i$의 모든 키 $v_i < v_j$ (for all $v_j$ in $L_j$)

**🔗 리프 노드 연결**

- $P_n$ **포인터**는 다음 리프 노드를 가리키는 **연결 포인터 역할**을 함.
- 이 덕분에 **리프 노드를 키 순서대로 순차적으로 순회하는 것이 가능**함 → **순차 처리에 효율적임**.

**🧩 내부 노드 구조 (Internal Nodes)**

- 내부 노드는 **리프 노드들을 위한 다단계 인덱스 역할**을 함.
- 포인터는 모두 **다른 트리 노드(리프 or 내부)를 가리킴**.
- 최대 $n$개의 포인터를 가질 수 있으며, 최소 $⌈n/2⌉$개의 포인터를 가져야 함.
- 이때 포인터 개수 $m$은 **fanout(분기도)** 라고 함.
- 내부 노드에 $m$개의 포인터가 있을 때:
    - $P_1$은 키 값 < K₁인 서브트리를 가리킴
    - $P_i (2 ≤ i ≤ m−1)는 K_{i-1} ≤ key < K_{i}$ 범위의 서브트리
    - P_m은 ≥ Kₘ₋₁인 키가 있는 서브트리

**🔝 루트 노드 예외**

- 루트는 내부 노드와 다르게 **⌈n/2⌉ 미만의 포인터도 가질 수 있음**.
- 단, 트리가 하나의 노드만으로 구성되지 않는 이상 **최소 2개의 포인터는 필수**임.

**🧱 예시: 다양한 차수의 B+-트리**

- n = 4인 경우 → 트리 높이가 더 높음.
- n = 6인 경우 → 같은 데이터를 표현해도 트리 높이가 낮아짐.
- 모든 예시는 **균형 트리** 구조임 → 루트에서 리프까지 경로 길이가 동일함.
- “B+-트리의 B는 Balanced(균형)를 의미함.”

**🔁 중복 키 처리 (Duplicate Keys)**

- 실제 DB에서는 **검색 키가 중복되는 경우가 많음**.
- 이 경우 처리 방식은 다음과 같음:

**① ❌ 단순 복제 방식 (비추천)**

- **리프 노드에 중복된 키를 모두 저장하고 각각 레코드 포인터를 가짐**.
- 내부 노드에도 중복 키가 들어갈 수 있어, **삽입/삭제 연산 복잡도 증가**함.

**② ❗ 버킷 방식 (단점 있음)**

- 각 키에 대해 **포인터들의 집합(버킷)을 저장**하는 방식.
- 포인터 수가 많아질 경우 **비효율 발생**.

**③ ✅ 복합 키 방식 (실무에서 가장 많이 사용됨)**

- **검색 키 + 기본 키(primary key)** 조합을 이용하여 **검색 키를 유일하게 만듦**.
- 예시: instructor 테이블에서 이름(name)이 중복될 수 있다면 → (name, ID)를 **복합 검색 키**로 사용함.
- name으로만 검색해도 **(name, ID)** 인덱스를 통해 효율적인 탐색이 가능함.