# Intro : DB 저장장치 구조

일반적인 데이터 저장구조 : 블록 단위로 읽고 쓴다.

DB의 데이터 저장구조 : 레코드 단위로 읽고 쓴다.

- (레코드의 크기) < (블록의 크기)

그러나 효율적인 접근 + 장애 복구를 위해 DB는 블록 단위를 계속 인식해야 함.

**→ 따라서 블록 구조를 고려하며 레코드가 저장되는 방법을 다룸**

**→ 또 레코드를 어떻게 파일에 배치할지 결정하는 방법을 다룸**

또한 데이터베이스는 데이터 사전의 내용들도 저장할 수 있어야 함.

- 데이터 사전 : 릴레이션의 스키마 정보 및 저장 구조를 관리하는 구조
- **따라서 데이터 사전을 다루는 방법 또한 역시 다룸**

데이터베이스 속 데이터를 다루기 위한 방법 역시 다룬다.

- CPU는 DB 속 데이터에 직접 접근이 불가!
- 따라서, SSD → RAM으로 데이터를 꺼내와야 함
- **SSD 속 DB 데이터 블록을 저장하는 데이터베이스 블록을 다룸**

**또한 분석용 질의에서 좋은 성능을 발휘하는 열 지향 저장방식을 다룸**

**추가적으로, 메모리 기반 데이터베이스(ex. Redis)에 대해서도 다룸.**

# 파일 구성

**💿 데이터베이스와 파일 시스템의 관계**

- 데이터베이스는 **운영체제가 관리하는 여러 개의 파일**로 매핑됨
- 이 파일들은 **디스크에 영구적으로 저장**됨
- 파일은 **레코드들의 논리적 시퀀스**로 구성되며, 각 레코드는 **디스크 블록**에 저장됨

**📦 블록 단위 저장**

- 파일은 **고정 길이 블록(block)** 단위로 나눔
    - 블록은 **저장 단위이자 데이터 전송 단위**
    - 보통 블록 크기는 **4KB ~ 8KB**이며, 생성 시 설정 가능
- 하나의 블록에는 여러 개의 레코드가 들어갈 수 있음
    - 단, 대부분의 DB는 **레코드 크기 ≤ 블록 크기**를 전제로 설계됨
    - **이미지, 대용량 데이터** 등은 예외이며, 13.2.2절에서 다룸

📌 **제약 조건**:

- **레코드는 반드시 하나의 블록 내에 완전히 포함되어야 함**
    
    → 블록 경계를 넘는 레코드는 허용하지 않음
    
    → 접근 속도 향상 및 단순화 목적
    

**🗃️ 고정 길이 vs 가변 길이 레코드**

- 릴레이션 간 튜플은 서로 크기가 다를 수 있음
- **두 가지 파일 구성 방식** 존재:
    1. **고정 길이 레코드**만 저장하는 파일
    2. **가변 길이 레코드**를 지원하는 파일
- 고정 길이 파일이 구현이 더 간단함
    
    → 따라서 먼저 고정 길이 레코드를 다루고 이후 가변 길이 방식 설명 예정
    

## 고정 길이 레코드

**✏️ 예시: instructor 레코드 구조**

```sql
type instructor = record
  ID         varchar(5);     // 5 byte
  name       varchar(20);    // 20 byte
  dept_name  varchar(20);    // 20 byte
  salary     numeric(8,2);   // 8 byte
end
```

📌 총 크기 = 5 + 20 + 20 + 8 = **53 byte**

**🔢 블록에 레코드 저장 시 문제점**

**1. ✅ 블록 경계 문제**

- 블록 크기가 53의 배수가 아닐 경우, **레코드가 두 블록에 걸쳐 저장**될 수 있음
- 레코드 하나 읽는데 블록을 **두 번 접근해야 하며, 이는** 비효율적임

**2. ❌ 삭제 처리 문제**

- 레코드 삭제 시, 공간을 **다른 레코드로 채워야 하거나**, 삭제된 레코드임을 표시할 **마커(marker)**가 필요함

**🛠️ 문제 해결 전략**

**✅ 문제 1 해결법 → 블록에 레코드를 꽉 채우지 않음**

- **블록 크기 ÷ 레코드 크기**로 최대 수 계산 후, **남는 공간은 버림**

**✅ 문제 2 해결법 → 삭제 후 공간 재사용**

- 단순히 뒤 레코드들을 앞으로 당기는 방식 → 너무 많은 이동 필요
- 대안: **마지막 레코드를 삭제된 위치로 이동** → 블록 접근 줄일 수 있음
- 최종 대안: **삭제된 레코드를 따로 표시하고, 링크드 리스트 형태로 관리**

**🧷 삭제 레코드 관리 - Free List**

- 파일의 맨 앞에 **파일 헤더(file header)** 영역 확보
    - 헤더는 삭제된 레코드의 주소를 담음
    - 이 삭제된 레코드는 다음 삭제된 레코드의 주소를 담고 있음 → **링크드 리스트 형태로 연결됨**
- 이를 **free list (여유 공간 리스트)**라고 부름
- 📌 삽입 시:
    - 헤더가 가리키는 위치에 새 레코드를 삽입하고
    - 헤더를 다음 삭제된 레코드로 갱신
- 📌 삽입할 공간이 없을 경우:
    - 파일 끝에 레코드를 추가함

## 가변 길이 레코드

💡 다음과 같은 경우에는 **고정 길이로는 저장이 어려움**:

- 문자열(string)과 같은 **가변 길이 필드** 존재
- **반복 필드(repeating fields)** → 예: 배열, 멀티셋(multiset)
- **하나의 파일에 여러 레코드 타입**이 섞여 있을 경우

**🛠️ 해결해야 할 두 가지 핵심 문제**

1. **개별 속성이 가변 길이일 때**, 어떻게 쉽게 추출할 수 있을지
2. **하나의 블록 내에 가변 길이 레코드들을 어떻게 저장할지**

**📐 가변 길이 속성을 포함한 레코드 구조**

레코드는 **두 부분**으로 구성됨:

1. **고정 길이 정보 부분**: 모든 레코드에서 동일한 구조
2. **가변 길이 속성 데이터**: 문자열 등 실질 데이터

**📌 저장 방식**

- 고정 길이 속성 (예: 숫자, 날짜 등)은 필요한 만큼 바이트를 바로 할당함
- 가변 길이 속성 (예: varchar)은 (offset, length) 쌍으로 표현
    - offset: 해당 데이터가 시작되는 위치
    - length: 데이터의 바이트 길이
- 가변 길이 데이터는 고정 정보 뒤에 연속적으로 저장됨

**🧩 예시 (그림 13.5 기반)**

![스크린샷 2025-05-20 오전 12.01.10.png](attachment:55b3f497-ae0b-48bb-9c20-199df0456714:스크린샷_2025-05-20_오전_12.01.10.png)

- instructor 레코드:
    - ID, name, dept_name → 가변 길이 문자열
    - salary → 고정 길이 숫자 (8 bytes)
- offset/length: 각 속성당 4 bytes 사용 (2+2)
- 문자열: 글자 수만큼 바이트 차지

**Null 값 표현: Null 비트맵 (null bitmap)**

- **null 값 여부를 1비트씩 기록하는 비트맵**
    
    → 예: 4개 속성이 있다면 1바이트면 충분
    
- 특정 속성이 null이라면 해당 비트를 1로 설정
    
    → 그 속성에 해당하는 데이터는 무시됨
    

**확장 포인트**

- 어떤 구현에서는 **null 속성에 대해 offset/length조차 저장하지 않음**
- 공간 절약 가능, 대신 속성 추출 시 연산 증가

**슬롯 페이지 구조 (Slotted-Page Structure)**

![스크린샷 2025-05-20 오전 12.04.03.png](attachment:7ecb00a6-8744-41f3-8aad-809ccaf94a20:스크린샷_2025-05-20_오전_12.04.03.png)

각 블록의 **헤더(header)**에 다음 정보 포함:

- 레코드 수
- 블록 내 여유 공간 끝 위치
- 각 레코드의 **위치(location)**와 **크기(size)**를 담은 **엔트리 배열**

**저장 방식**

- **레코드는 블록의 끝부터 거꾸로 저장**
- **헤더 엔트리 → 앞에서부터**
- **여유 공간 → 헤더 배열 끝과 레코드 시작 사이**

**🔁 삽입/삭제/갱신 처리**

| **동작** | **설명** |
| --- | --- |
| 삽입 | 여유 공간의 끝에 공간 할당 → 헤더에 위치/크기 추가 |
| 삭제 | 해당 엔트리의 크기를 -1로 설정 (삭제 표시) |
| 정리 | 삭제된 레코드 이후의 레코드를 앞으로 당겨서 공간 재정렬 |
| 갱신 | 공간 여유가 있으면 레코드 크기 변경도 가능 |

삭제된 레코드를 정리할 때 전체 레코드를 이동하는 작업은 **블록 크기가 작기 때문에(4~8KB)** 부담되지 않음

**🔗 간접 참조를 통한 유연성 확보**

블록 외부에서 **레코드 직접 주소를 참조하지 않음.** 

- 대신 헤더 엔트리를 참조함
- 레코드 이동 시에도 **간접 포인터만 갱신하면 됨**
- **조각화(fragmentation)**를 방지하면서도 유연하게 대응 가능

## **대용량 객체 저장**

**📦 대용량 데이터의 예**

- DB는 **디스크 블록보다 훨씬 큰 데이터**도 저장해야 할 수 있음
    - 이미지 🖼️, 오디오 🎵 → 수 MB
    - 동영상 🎥 → 수 GB
- SQL은 이런 데이터를 위해 **BLOB (Binary Large OBject)**, **CLOB (Character Large OBject)** 타입을 제공함

**📏 일반적인 제약: 블록 크기 이하**

- 많은 DB는 개별 **레코드 크기를 블록 크기 이하로 제한**함
- 따라서, **레코드 내에 대용량 객체 전체를 직접 저장하지 않음**
- 대신, 대용량 객체는 **분리된 영역에 저장**되고,
    
    → 레코드에는 해당 객체의 **논리적 포인터**만 포함함
    

**🗃️ 대용량 객체 저장 방식**

**① DB 외부 파일 시스템에 저장**

- DB가 관리하는 별도 **파일 시스템 영역**에 저장
- 레코드에는 **파일 경로(path)**만 저장함
- 예: /media/video123.mp4

**② DB 내부 구조로 저장**

- 대용량 객체를 **DB 내부의 파일 구조**로 관리
- 특히 **B+-트리 파일 구조** 사용 가능
    - **효율적인 랜덤 접근/부분 접근 가능**
    - 전체 객체 읽기, 특정 바이트 범위 접근, 부분 삽입/삭제 등 지원

**🚧 성능 및 백업 측면 문제**

| **문제** | **설명** |
| --- | --- |
| 💨 성능 | DB 인터페이스를 통해 대용량 객체에 접근 시 느릴 수 있음 |
| 🧱 백업 크기 | DB 덤프 시 전체 데이터가 포함되므로 백업 크기 증가 |

**🔄 외부 파일 시스템 저장 시 고려사항**

1. **❌ 외부 저장의 단점**
- 레코드가 참조하는 파일이 삭제되었을 경우 무결성 제약(foreign key-like) 위반 발생
- DB 권한 시스템이 파일 시스템에는 적용되지 않음

1. **일부 DB의 통합 지원**
- 몇몇 DBMS는 **파일 시스템과의 통합**을 지원하여 다음 기능 제공:
    - 파일 삭제 방지 (참조 중이면 삭제 차단)
    - 접근 제어 연동 (DB 권한과 파일 접근 동기화)
- 예: Oracle의 SecureFiles, Database File System (DBFS)

# 파일 내 레코드 조직 방식

**📂 관계(Relation)는 레코드 집합**

- 지금까지는 레코드가 파일 내에서 어떻게 표현되는지를 다룸
- 이번에는 레코드를 어떻게 조직화해서 저장할지에 대한 방식들을 소개함

**📌 주요 레코드 조직 방식**

| **조직 방식** | **설명** |
| --- | --- |
| **Heap file** | 아무 순서 없이, 공간만 있다면 아무 곳에나 저장함 |
| **Sequential file** | 지정된 검색 키(search key)를 기준으로 **정렬된 순서**로 저장 |
| **Multitable clustering file** | 여러 관계의 레코드를 **하나의 파일** 또는 **블록에 함께 저장**하여 **Join 성능 향상** |
| **B+-tree file** | **정렬된 접근 지원** + 많은 삽입/삭제에도 성능 유지 가능한 구조 |
| **Hashing file** | 특정 속성에 대해 **해시 함수**를 계산해 저장 블록을 결정 |

## 힙 파일 (Heap file)

**🧱 기본 개념**

- 레코드는 파일 내 **아무 위치**에 저장 가능
- **삽입 시**에는 보통 **파일 끝에 추가**
- 하지만 삭제가 발생하면, **비어 있는 공간을 재활용**하는 것이 효율적임
- 효율적으로 빈 공간을 찾기 위해 **free-space map**이라는 구조를 사용함

**📍 Free-Space Map (여유 공간 맵)**

**✅ 정의**

- 각 블록마다 **얼마나 공간이 비어 있는지**를 기록한 배열 구조
- 배열의 **각 항목은 하나의 블록**을 나타냄
- PostgreSQL) 1 byte로 표현, 값을 **256으로 나누면 비율**이 됨

**📌 예시**

- 3비트를 사용해 저장 시 → 값 7이면, **7/8 이상 공간이 비어 있음**

![스크린샷 2025-05-21 오전 12.32.13.png](attachment:6eee65c1-c405-4949-9425-59a45f4330d1:스크린샷_2025-05-21_오전_12.32.13.png)

![스크린샷 2025-05-21 오전 12.32.25.png](attachment:f513f6b2-9aa5-48b2-9c79-d2236a15ee27:스크린샷_2025-05-21_오전_12.32.25.png)

**📦 삽입 시 처리 과정**

1. **free-space map을 탐색**해 충분한 공간이 있는 블록을 찾음
2. 해당 블록에 레코드 저장
3. 공간 정보가 변경되면 → free-space map도 **갱신**함
- 직접 블록을 다 읽는 것보다 free-space map 탐색이 훨씬 빠름

**🔁 2단계 Free-Space Map**

- 파일이 매우 클 경우, free-space map 탐색조차 느릴 수 있음
- **100개 단위로 묶어서**, 각 묶음에 대해 **최대 free-space 값을 저장하는 상위 맵**을 만듦
    - 이를 통해 **탐색 속도 100배 향상 가능**
    

**📌 작동 방식**

1. 2단계 맵을 먼저 스캔해 적절한 묶음을 찾음
2. 해당 묶음(100개)의 하위 맵을 스캔해 실제 블록을 찾음
3. 필요하다면 **3단계, 4단계 구조**도 확장 가능

**🔄 free-space map의 유지 및 동기화**

- **레코드 삽입/삭제** 시마다 디스크에 쓰는 건 비효율적
- 따라서 **주기적으로 갱신함**
- 이로 인해 발생 가능한 문제:

| **상황** | **영향** |
| --- | --- |
| 맵이 공간이 있다고 주장 → 실제 없음 | 블록 접근 시 오류 감지 후 재탐색함 |
| 맵이 공간이 없다고 주장 → 실제 있음 | 문제는 없지만 공간 낭비 발생 |
- 주기적으로 관계(relation)를 스캔하여 **맵을 재계산하고 디스크에 기록함**