# Intro : DB 저장장치 구조

일반적인 데이터 저장구조 : 블록 단위로 읽고 쓴다.

DB의 데이터 저장구조 : 레코드 단위로 읽고 쓴다.

- (레코드의 크기) < (블록의 크기)

그러나 효율적인 접근 + 장애 복구를 위해 DB는 블록 단위를 계속 인식해야 함.

**→ 따라서 블록 구조를 고려하며 레코드가 저장되는 방법을 다룸**

**→ 또 레코드를 어떻게 파일에 배치할지 결정하는 방법을 다룸**

또한 데이터베이스는 데이터 사전의 내용들도 저장할 수 있어야 함.

- 데이터 사전 : 릴레이션의 스키마 정보 및 저장 구조를 관리하는 구조
- **따라서 데이터 사전을 다루는 방법 또한 역시 다룸**

데이터베이스 속 데이터를 다루기 위한 방법 역시 다룬다.

- CPU는 DB 속 데이터에 직접 접근이 불가!
- 따라서, SSD → RAM으로 데이터를 꺼내와야 함
- **SSD 속 DB 데이터 블록을 저장하는 데이터베이스 블록을 다룸**

**또한 분석용 질의에서 좋은 성능을 발휘하는 열 지향 저장방식을 다룸**

**추가적으로, 메모리 기반 데이터베이스(ex. Redis)에 대해서도 다룸.**

# 파일 구성

**💿 데이터베이스와 파일 시스템의 관계**

- 데이터베이스는 **운영체제가 관리하는 여러 개의 파일**로 매핑됨
- 이 파일들은 **디스크에 영구적으로 저장**됨
- 파일은 **레코드들의 논리적 시퀀스**로 구성되며, 각 레코드는 **디스크 블록**에 저장됨

**📦 블록 단위 저장**

- 파일은 **고정 길이 블록(block)** 단위로 나눔
    - 블록은 **저장 단위이자 데이터 전송 단위**
    - 보통 블록 크기는 **4KB ~ 8KB**이며, 생성 시 설정 가능
- 하나의 블록에는 여러 개의 레코드가 들어갈 수 있음
    - 단, 대부분의 DB는 **레코드 크기 ≤ 블록 크기**를 전제로 설계됨
    - **이미지, 대용량 데이터** 등은 예외이며, 13.2.2절에서 다룸

📌 **제약 조건**:

- **레코드는 반드시 하나의 블록 내에 완전히 포함되어야 함**
    
    → 블록 경계를 넘는 레코드는 허용하지 않음
    
    → 접근 속도 향상 및 단순화 목적
    

**🗃️ 고정 길이 vs 가변 길이 레코드**

- 릴레이션 간 튜플은 서로 크기가 다를 수 있음
- **두 가지 파일 구성 방식** 존재:
    1. **고정 길이 레코드**만 저장하는 파일
    2. **가변 길이 레코드**를 지원하는 파일
- 고정 길이 파일이 구현이 더 간단함
    
    → 따라서 먼저 고정 길이 레코드를 다루고 이후 가변 길이 방식 설명 예정
    

## 고정 길이 레코드

**✏️ 예시: instructor 레코드 구조**

```sql
type instructor = record
  ID         varchar(5);     // 5 byte
  name       varchar(20);    // 20 byte
  dept_name  varchar(20);    // 20 byte
  salary     numeric(8,2);   // 8 byte
end
```

📌 총 크기 = 5 + 20 + 20 + 8 = **53 byte**

**🔢 블록에 레코드 저장 시 문제점**

**1. ✅ 블록 경계 문제**

- 블록 크기가 53의 배수가 아닐 경우, **레코드가 두 블록에 걸쳐 저장**될 수 있음
- 레코드 하나 읽는데 블록을 **두 번 접근해야 하며, 이는** 비효율적임

**2. ❌ 삭제 처리 문제**

- 레코드 삭제 시, 공간을 **다른 레코드로 채워야 하거나**, 삭제된 레코드임을 표시할 **마커(marker)**가 필요함

**🛠️ 문제 해결 전략**

**✅ 문제 1 해결법 → 블록에 레코드를 꽉 채우지 않음**

- **블록 크기 ÷ 레코드 크기**로 최대 수 계산 후, **남는 공간은 버림**

**✅ 문제 2 해결법 → 삭제 후 공간 재사용**

- 단순히 뒤 레코드들을 앞으로 당기는 방식 → 너무 많은 이동 필요
- 대안: **마지막 레코드를 삭제된 위치로 이동** → 블록 접근 줄일 수 있음
- 최종 대안: **삭제된 레코드를 따로 표시하고, 링크드 리스트 형태로 관리**

**🧷 삭제 레코드 관리 - Free List**

- 파일의 맨 앞에 **파일 헤더(file header)** 영역 확보
    - 헤더는 삭제된 레코드의 주소를 담음
    - 이 삭제된 레코드는 다음 삭제된 레코드의 주소를 담고 있음 → **링크드 리스트 형태로 연결됨**
- 이를 **free list (여유 공간 리스트)**라고 부름
- 📌 삽입 시:
    - 헤더가 가리키는 위치에 새 레코드를 삽입하고
    - 헤더를 다음 삭제된 레코드로 갱신
- 📌 삽입할 공간이 없을 경우:
    - 파일 끝에 레코드를 추가함

## 가변 길이 레코드

💡 다음과 같은 경우에는 **고정 길이로는 저장이 어려움**:

- 문자열(string)과 같은 **가변 길이 필드** 존재
- **반복 필드(repeating fields)** → 예: 배열, 멀티셋(multiset)
- **하나의 파일에 여러 레코드 타입**이 섞여 있을 경우

**🛠️ 해결해야 할 두 가지 핵심 문제**

1. **개별 속성이 가변 길이일 때**, 어떻게 쉽게 추출할 수 있을지
2. **하나의 블록 내에 가변 길이 레코드들을 어떻게 저장할지**

**📐 가변 길이 속성을 포함한 레코드 구조**

레코드는 **두 부분**으로 구성됨:

1. **고정 길이 정보 부분**: 모든 레코드에서 동일한 구조
2. **가변 길이 속성 데이터**: 문자열 등 실질 데이터

**📌 저장 방식**

- 고정 길이 속성 (예: 숫자, 날짜 등)은 필요한 만큼 바이트를 바로 할당함
- 가변 길이 속성 (예: varchar)은 (offset, length) 쌍으로 표현
    - offset: 해당 데이터가 시작되는 위치
    - length: 데이터의 바이트 길이
- 가변 길이 데이터는 고정 정보 뒤에 연속적으로 저장됨

**🧩 예시 (그림 13.5 기반)**

![스크린샷 2025-05-20 오전 12.01.10.png](attachment:55b3f497-ae0b-48bb-9c20-199df0456714:스크린샷_2025-05-20_오전_12.01.10.png)

- instructor 레코드:
    - ID, name, dept_name → 가변 길이 문자열
    - salary → 고정 길이 숫자 (8 bytes)
- offset/length: 각 속성당 4 bytes 사용 (2+2)
- 문자열: 글자 수만큼 바이트 차지

**Null 값 표현: Null 비트맵 (null bitmap)**

- **null 값 여부를 1비트씩 기록하는 비트맵**
    
    → 예: 4개 속성이 있다면 1바이트면 충분
    
- 특정 속성이 null이라면 해당 비트를 1로 설정
    
    → 그 속성에 해당하는 데이터는 무시됨
    

**확장 포인트**

- 어떤 구현에서는 **null 속성에 대해 offset/length조차 저장하지 않음**
- 공간 절약 가능, 대신 속성 추출 시 연산 증가

### **슬롯 페이지 구조 (Slotted-Page Structure)**

![스크린샷 2025-05-20 오전 12.04.03.png](attachment:7ecb00a6-8744-41f3-8aad-809ccaf94a20:스크린샷_2025-05-20_오전_12.04.03.png)

**구조 (그림 13.6 기반)**

- 각 블록의 **헤더(header)**에 다음 정보 포함:
    - 레코드 수
    - 블록 내 여유 공간 끝 위치
    - 각 레코드의 **위치(location)**와 **크기(size)**를 담은 **엔트리 배열**

### **저장 방식**

- **레코드는 블록의 끝부터 거꾸로 저장**
- **헤더 엔트리 → 앞에서부터**
- **여유 공간 → 헤더 배열 끝과 레코드 시작 사이**

**🔁 삽입/삭제/갱신 처리**

| **동작** | **설명** |
| --- | --- |
| 삽입 | 여유 공간의 끝에 공간 할당 → 헤더에 위치/크기 추가 |
| 삭제 | 해당 엔트리의 크기를 -1로 설정 (삭제 표시) |
| 정리 | 삭제된 레코드 이후의 레코드를 앞으로 당겨서 공간 재정렬 |
| 갱신 | 공간 여유가 있으면 레코드 크기 변경도 가능 |

삭제된 레코드를 정리할 때 전체 레코드를 이동하는 작업은 **블록 크기가 작기 때문에(4~8KB)** 부담되지 않음

**🔗 간접 참조를 통한 유연성 확보**

블록 외부에서 **레코드 직접 주소를 참조하지 않음.** 

- 대신 헤더 엔트리를 참조함
- 레코드 이동 시에도 **간접 포인터만 갱신하면 됨**
- **조각화(fragmentation)**를 방지하면서도 유연하게 대응 가능